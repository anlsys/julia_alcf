"""
Report generation - runs all benchmarks and generates a markdown report.
"""

using Dates
using InteractiveUtils

"""
    BenchmarkResult

Stores results from a single benchmark measurement.
"""
struct BenchmarkResult
    name::String
    value::Float64
    unit::String
end

"""
    ReportData

Accumulates benchmark results for report generation.
"""
mutable struct ReportData
    system_name::String
    backend_name::String
    num_devices::Int
    num_ranks::Int
    timestamp::DateTime
    julia_versioninfo::String
    backend_versioninfo::String
    results::Vector{BenchmarkResult}
end

ReportData() = ReportData("", "", 0, 0, now(), "", "", BenchmarkResult[])

"""
    capture_versioninfo() -> String

Capture Julia's versioninfo() output as a string.
"""
function capture_versioninfo()
    io = IOBuffer()
    versioninfo(io)
    return String(take!(io))
end

"""
    get_backend_versioninfo(backend) -> String

Get backend-specific version information. Extended by package extensions.
"""
function get_backend_versioninfo(backend)
    return "Backend version info not available for $(typeof(backend))"
end

# Global report data (set by run_all, used by individual benchmarks)
const REPORT_DATA = Ref{Union{Nothing, ReportData}}(nothing)

function is_reporting()
    return REPORT_DATA[] !== nothing
end

function add_result!(name::String, value::Float64, unit::String)
    if REPORT_DATA[] !== nothing
        push!(REPORT_DATA[].results, BenchmarkResult(name, value, unit))
    end
end

"""
    generate_markdown(data::ReportData) -> String

Generate a markdown report from the collected benchmark data.
"""
function generate_markdown(data::ReportData)
    io = IOBuffer()

    println(io, "# GPU Benchmark Report: $(data.system_name)")
    println(io)
    println(io, "**Date:** $(Dates.format(data.timestamp, "yyyy-mm-dd HH:MM:SS"))")
    println(io)
    println(io, "**Backend:** $(data.backend_name)")
    println(io)
    println(io, "**Devices:** $(data.num_devices)")
    println(io)
    println(io, "**MPI Ranks:** $(data.num_ranks)")
    println(io)
    println(io, "---")
    println(io)

    # Julia version info
    println(io, "## System Information")
    println(io)
    println(io, "### Julia")
    println(io)
    println(io, "```")
    print(io, data.julia_versioninfo)
    println(io, "```")
    println(io)

    # Backend version info
    println(io, "### GPU Backend")
    println(io)
    println(io, "```")
    print(io, data.backend_versioninfo)
    println(io, "```")
    println(io)
    println(io, "---")
    println(io)

    # Group results by category (mutually exclusive)
    flops_results = filter(r -> occursin("Flops", r.name) || occursin("GEMM", r.name), data.results)
    memory_results = filter(r -> occursin("Triad", r.name), data.results)
    pci_results = filter(r -> occursin("PCIe", r.name), data.results)
    p2p_results = filter(r -> occursin("P2P", r.name) || occursin("Intranode", r.name), data.results)

    # Compute Performance
    if !isempty(flops_results)
        println(io, "## Compute Performance")
        println(io)
        println(io, "| Benchmark | Performance | Unit |")
        println(io, "|-----------|-------------|------|")
        for r in flops_results
            println(io, "| $(r.name) | $(round(r.value, digits=2)) | $(r.unit) |")
        end
        println(io)
    end

    # Memory Bandwidth
    if !isempty(memory_results)
        println(io, "## Memory Bandwidth")
        println(io)
        println(io, "| Benchmark | Bandwidth | Unit |")
        println(io, "|-----------|-----------|------|")
        for r in memory_results
            println(io, "| $(r.name) | $(round(r.value, digits=2)) | $(r.unit) |")
        end
        println(io)
    end

    # PCIe Bandwidth
    if !isempty(pci_results)
        println(io, "## PCIe Bandwidth")
        println(io)
        println(io, "| Benchmark | Bandwidth | Unit |")
        println(io, "|-----------|-----------|------|")
        for r in pci_results
            println(io, "| $(r.name) | $(round(r.value, digits=2)) | $(r.unit) |")
        end
        println(io)
    end

    # GPU P2P Bandwidth
    if !isempty(p2p_results)
        println(io, "## GPU-to-GPU Bandwidth")
        println(io)
        println(io, "| Benchmark | Bandwidth | Unit |")
        println(io, "|-----------|-----------|------|")
        for r in p2p_results
            println(io, "| $(r.name) | $(round(r.value, digits=2)) | $(r.unit) |")
        end
        println(io)
    end

    println(io, "---")
    println(io)
    println(io, "*Generated by ALCFBenchmarks.jl*")

    return String(take!(io))
end

"""
    run_all(backend, comm; output::String="", system_name::String="")

Run all benchmarks and optionally generate a markdown report.

# Arguments
- `backend`: KernelAbstractions backend
- `comm`: MPI communicator
- `output`: Output file path for markdown report (optional)
- `system_name`: Name for the system (used in report title, defaults to hostname)
"""
function run_all(backend, comm; output::String="", system_name::String="", kwargs...)
    world_rank = MPI.Comm_rank(comm)
    world_size = MPI.Comm_size(comm)

    # Initialize report data
    if world_rank == 0
        REPORT_DATA[] = ReportData()
        REPORT_DATA[].system_name = isempty(system_name) ? gethostname() : system_name
        REPORT_DATA[].backend_name = string(typeof(backend))
        REPORT_DATA[].num_devices = KA.ndevices(backend)
        REPORT_DATA[].num_ranks = world_size
        REPORT_DATA[].timestamp = now()
        REPORT_DATA[].julia_versioninfo = capture_versioninfo()
        REPORT_DATA[].backend_versioninfo = get_backend_versioninfo(backend)
    end

    # Run all benchmarks
    if world_rank == 0
        println("=" ^ 60)
        println("Running all benchmarks...")
        println("=" ^ 60)
        println()
    end

    # 1. FLOPS benchmark
    if world_rank == 0
        println("--- FLOPS Benchmark ---")
    end
    run_flops(backend, comm)
    MPI.Barrier(comm)
    if world_rank == 0
        println()
    end

    # 2. GEMM benchmark
    if world_rank == 0
        println("--- GEMM Benchmark ---")
    end
    run_gemm(backend, comm; size=get(kwargs, :gemm_size, 8192))
    MPI.Barrier(comm)
    if world_rank == 0
        println()
    end

    # 3. Triad benchmark
    if world_rank == 0
        println("--- Triad Benchmark ---")
    end
    run_triad(backend, comm)
    MPI.Barrier(comm)
    if world_rank == 0
        println()
    end

    # 4. PCI benchmark
    if world_rank == 0
        println("--- PCI Benchmark ---")
    end
    run_pci(backend, comm)
    MPI.Barrier(comm)
    if world_rank == 0
        println()
    end

    # 5. Intranode benchmark
    if world_rank == 0
        println("--- Intranode P2P Benchmark ---")
    end
    run_intranode(backend, comm)
    MPI.Barrier(comm)
    if world_rank == 0
        println()
    end

    # 6. Peer2Peer benchmark (only if multiple ranks and not skipped)
    # Note: GPU-aware MPI may not work on all systems, use --skip-peer2peer if it crashes
    skip_p2p = get(kwargs, :skip_peer2peer, false)
    if world_size >= 2 && !skip_p2p
        if world_rank == 0
            println("--- Peer2Peer MPI Benchmark ---")
        end
        run_peer2peer(backend, comm)
        MPI.Barrier(comm)
        if world_rank == 0
            println()
        end
    elseif world_size >= 2 && skip_p2p
        if world_rank == 0
            println("--- Peer2Peer MPI Benchmark (SKIPPED) ---")
            println()
        end
    end

    # Generate report if output specified
    if world_rank == 0 && !isempty(output)
        report = generate_markdown(REPORT_DATA[])
        open(output, "w") do f
            write(f, report)
        end
        println("=" ^ 60)
        println("Report written to: $output")
        println("=" ^ 60)
    end

    # Clear report data
    if world_rank == 0
        REPORT_DATA[] = nothing
    end
end
